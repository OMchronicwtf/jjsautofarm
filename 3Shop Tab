-- =======================
-- Shop Tab Module
-- =======================

return function(Window, player, QuestEvent, quests, RunService, serverEvent)
    -- Load stockTable locally within this module
    local stockTable = loadstring(game:HttpGet("https://github.com/OMchronicwtf/jjsautofarm/raw/refs/heads/main/Stock%20Table"))()

    -- Ordered keys to match the exact sequence in the stockTable definition
    local orderedKeys = {
        "MV1", "MV2", "MV3", "MV9", "MV8", "MV14", "MV5", "MV6", "MV7", "MV15",
        "MV10", "MV12", "MV11", "MV13"
    }

    -- Reference to AvailableStock folder (for stock items only)
    local availableStock = game:GetService("ReplicatedStorage"):WaitForChild("AvailableStock")

    -- Create the Shop Tab
    local ShopTab = Window:CreateTab("Shop", "shopping-bag") -- Using Lucide icon for shop theme

    -- Create a Section for organization
    ShopTab:CreateSection("Purchase Items")

    -- Function to refresh dropdown based on AvailableStock children (stock items)
    local ItemDropdown
    local function refreshDropdown()
        local availableKeys = {}
        for _, child in ipairs(availableStock:GetChildren()) do
            table.insert(availableKeys, child.Name)
        end

        -- Sort available keys to match orderedKeys sequence
        table.sort(availableKeys, function(a, b)
            local ia = table.find(orderedKeys, a)
            local ib = table.find(orderedKeys, b)
            return (ia or math.huge) < (ib or math.huge)
        end)

        local options = {}
        for _, key in ipairs(availableKeys) do
            local data = stockTable[key]
            if data then
                table.insert(options, "[Stock] " .. data.Name .. " (" .. key .. ") - " .. data.Price)
            end
        end

        ItemDropdown:Refresh(options)

        -- Reset to first option if no selection and options available
        if #options > 0 and #ItemDropdown.CurrentOption == 0 then
            ItemDropdown:Set({options[1]})
        end
    end

    -- Initial empty dropdown (will be refreshed immediately after)
    ItemDropdown = ShopTab:CreateDropdown({
        Name = "Select Stock Item",
        Options = {},
        CurrentOption = {},
        MultipleOptions = false,
        Flag = "ShopItemDropdown",
        Callback = function(Options)
            print("Selected stock item(s):", table.concat(Options, ", "))
        end,
    })

    -- Initial refresh
    refreshDropdown()

    -- Connect events to update dropdown on stock changes
    availableStock.ChildAdded:Connect(refreshDropdown)
    availableStock.ChildRemoved:Connect(refreshDropdown)

    -- Helper function to parse price to number (e.g., "$ 75,000" -> 75000)
    local function parsePrice(priceStr)
        return tonumber(priceStr:gsub("[^%d]", ""))
    end

    -- Button to buy the selected stock item
    local BuyStockButton = ShopTab:CreateButton({
        Name = "Buy Selected Stock Item",
        Callback = function()
            local selected = ItemDropdown.CurrentOption[1]
            if not selected then
                print("No stock item selected!")
                return
            end

            -- Parse the key (e.g., "MV3") from the formatted option
            local key = selected:match("%((%u%w+)%)")
            if not key then
                print("Could not parse stock item key from selection!")
                return
            end

            local data = stockTable[key]
            if not data then
                print("Stock item data not found!")
                return
            end

            -- Get player's cash
            local playerData = player:WaitForChild("Data")
            local playerCash = playerData:WaitForChild("Cash").Value

            local itemPrice = parsePrice(data.Price)
            if playerCash < itemPrice then
                print("Insufficient funds for stock item! Need " .. itemPrice .. " but have " .. playerCash)
                return
            end

            if QuestEvent then
                QuestEvent:FireServer({ Item = key, Type = "StockBuy" })
                print("Attempted to buy stock: " .. key .. " (" .. data.Name .. ")")
            else
                print("QuestEvent not available!")
            end
        end,
    })

    -- Section for regular moves (all from stockTable, not just stock)
    ShopTab:CreateSection("Purchase Regular Moves")

    -- Build options for all regular moves
    local regularOptions = {}
    for _, key in ipairs(orderedKeys) do
        local data = stockTable[key]
        if data then
            table.insert(regularOptions, data.Name .. " (" .. key .. ") - " .. data.Price)
        end
    end

    -- Dropdown for regular moves
    local RegularDropdown = ShopTab:CreateDropdown({
        Name = "Select Regular Move",
        Options = regularOptions,
        CurrentOption = {regularOptions[1] or ""},
        MultipleOptions = false,
        Flag = "RegularMoveDropdown",
        Callback = function(Options)
            print("Selected regular move(s):", table.concat(Options, ", "))
        end,
    })

    -- Button to buy the selected regular move
    local BuyRegularButton = ShopTab:CreateButton({
        Name = "Buy Selected Regular Move",
        Callback = function()
            local selected = RegularDropdown.CurrentOption[1]
            if not selected then
                print("No regular move selected!")
                return
            end

            -- Parse the key (e.g., "MV1") from the formatted option
            local key = selected:match("%((%u%w+)%)")
            if not key then
                print("Could not parse regular move key from selection!")
                return
            end

            local data = stockTable[key]
            if not data then
                print("Regular move data not found!")
                return
            end

            -- Get player's cash
            local playerData = player:WaitForChild("Data")
            local playerCash = playerData:WaitForChild("Cash").Value

            local itemPrice = parsePrice(data.Price)
            if playerCash < itemPrice then
                print("Insufficient funds for regular move! Need " .. itemPrice .. " but have " .. playerCash)
                return
            end

            if serverEvent then
                serverEvent:InvokeServer({ Arg = "BuyMove", Move = key })
                print("Attempted to buy regular move: " .. key .. " (" .. data.Name .. ")")
            else
                print("serverEvent not available!")
            end
        end,
    })

    return ShopTab -- Return the tab reference to match other modules
end
